# -*- coding: utf-8 -*-
"""Convolution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_0OmxyJd5cOBLk7R7K1rX-v-kjmmNIre
"""

import random 
import numpy as np
from math import floor, ceil
import matplotlib.pyplot as plt
import cv2

print()
print("Solution of Q3-------------------------------------------------------------")
print()

#load image
input_image=cv2.imread('cameraman.jpg', 0)

l=256  #intensity range 0 - 255
m, n = input_image.shape

count_input=[0]*256
count_input2 = [0]*256
pdf_input = [0]*256
cdf_input = [0]*256

#reading using np.where function
for i in range(l):
    count_input[i] = np.where(input_image == i)   #stores indices
    count_input2[i] = len(list(zip(*count_input[i])))   #store count
    pdf_input[i] = count_input2[i]/(m*n)  #store probability density 

#plotting input image
fig=plt.figure(figsize=(25, 10))												
fig.add_subplot(1,2,1)
plt.imshow(input_image, cmap='gray', vmin=0, vmax=255)
plt.colorbar(orientation="horizontal")
plt.title("Input image")

#plotting histogram of input image
fig.add_subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_input)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Normalized histogram of Input image")
plt.show()

#calculating cumulative distribution
cdf_input[0] = pdf_input[0]
for i in range(1,l):
    cdf_input[i] = pdf_input[i] + cdf_input[i - 1]

#Using transformation function L-1*(cdf)
t_s_value = [0]*256
output_image = np.copy(input_image)

for i in range(l):
    t_s_value[i] = round( (l - 1) * cdf_input[i] )
    output_image[ count_input[i] ] = t_s_value[i]    #mapping r to s

#count, pdf of new equalized image
count_output=[0]*256
count_output2 = [0]*256
pdf_output = [0]*256

for i in range(l):
    count_output[i] = np.where(output_image == i)
    count_output2[i] = len(list(zip(*count_output[i])))
    pdf_output[i] = count_output2[i]/(m*n)

print()
print()
fig=plt.figure(figsize=(15, 7))												
fig.add_subplot(1,2,1)
plt.imshow(output_image, cmap='gray', vmin=0, vmax=255)
plt.colorbar(orientation="horizontal")
plt.title("Equalized image")

fig.add_subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_output)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Normalized Equalized histogram of Input image")
plt.show()

################################################################################
print()
print("Solution of Q4-------------------------------------------------------------")
print()

gamma = 0.5 # gamma < 1, so target image will be brighter

#Getting target image using gamma transformation, c = 255/(max value in image ^ gamma)
# s = c * (r^gamma)
max_value = input_image.max()
target = np.array(255*(input_image / max_value) ** gamma, dtype = 'uint8')

count_target=[0]*256        # stores indices
count_target2 = [0]*256     # stores count
pdf_target = [0]*256        
cdf_target = [0]*256

#reading using np.where function
for i in range(l):
    count_target[i] = np.where(target == i)   #stores indices
    count_target2[i] = len(list(zip(*count_target[i])))   #store count
    pdf_target[i] = count_target2[i]/(m*n)  #store probability density 

fig=plt.figure(figsize=(15, 7))										#Plotting Input image and histogram			
fig.add_subplot(1,2,1)
plt.imshow(input_image, cmap='gray', vmin=0, vmax=255)
plt.colorbar(orientation="horizontal")
plt.title("Input image")

fig.add_subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_input)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Normalized histogram of Input image")
plt.show()

fig=plt.figure(figsize=(15, 7))										#Plotting target image and histogram			
fig.add_subplot(1,2,1)
plt.imshow(target, cmap='gray', vmin=0, vmax=255)
plt.colorbar(orientation="horizontal")
plt.title("Target image")

fig.add_subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_target)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Normalized histogram of target image")
plt.show()

#calculating cumulative distribution of target image
cdf_target[0] = pdf_target[0]
for i in range(1,l):
    cdf_target[i] = pdf_target[i] + cdf_target[i - 1]

s_input = []
s_target = []

for i in range(256):											#Computing transfer function for both
	s_input.append( (l-1) * cdf_input[i])
	s_target.append( (l-1) * cdf_target[i]) 

mapping=[]

for i in range(256):
    											#mapping r to z
	temp = s_input[i]
	current_min = abs(temp - s_target[0])
	take=0

	for j in range(256):
		if (abs(temp - s_target[j]) < current_min):
			current_min=abs(temp - s_target[j])
			take=j
	mapping.append(take)

matched = np.copy(input_image)

for i in range(m):
	for j in range(n):
		matched[i][j]=mapping[input_image[i][j]]

count_matched=[0]*256
for i in range(m):
	for j in range(n):
		count_matched[matched[i][j]]+=1

pdf_matched=[]

for i in range(256):
	pdf_matched.append(count_matched[i]/(m*n))


fig=plt.figure(figsize=(15, 7))									#Plotting Matched Image and its Histogram 
fig.add_subplot(1,2,1)
plt.imshow(matched, cmap='gray', vmin=0, vmax=255)
plt.colorbar(orientation="horizontal")
plt.title("Matched Output image")

fig.add_subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_matched)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Histogram of Matched Output image")
plt.show()

print("Input Transformation\n", s_input, "\n\n")
print("target Transformation\n", s_target, "\n\n")
print("Mapping\n", mapping, "\n\n")


################################################################################
#Question 5
print()
print("Solution of Q5-------------------------------------------------------------")
print()

#for doing 0 padding around the input
def padding_with_0(take):
    m=len(take)
    n=len(take[0])
    output= [[0 for v in range(n+2)] for w in range(m+2)]
    i = 0
    j = 0
    while(i < (m+2)):
        j = 0
        while(j < (n+2)):
            if (i == 0 or i == m+1 or j == 0 or j == n+1):
                output[i][j] = 0
            else:
                output[i][j] = take[i - 1][j - 1]
            j += 1
        i +=1
    return output

#rotating by 180
def rotate_180(h):
    v = len(h)
    w = len(h[0])
            
    flipped = [[0 for i in range(w)] for j in range(v)]

    for i in range(v):
        for j in range(w):

            if i > 1 and j > 1:
                return(flipped)

            flipped[i][j] = h[v-1-i][w-1-j]
            flipped[v-1-i][w-1-j] = h[i][j]

#random matrix
def rand_matrix(take):
    for i in range(3):
        for j in range(3):
            take[i][j] = random.randrange(0,6)
    return(take)

#*******************************************************************************

I = [[0,0,0],[0,1,0],[0,0,0]]

W = [[1,2,3], [4,5,6], [7,8,9]]

I = rand_matrix(I)
W = rand_matrix(W)

Padded_I = padding_with_0(I)

flipped = rotate_180(W)

print("Original Filter:")
print()

for i in range(3):
    print(W[i])

print()
print("Flipped Filter:")
print()

for i in range(3):
    print(flipped[i])

print()
print("Input:")
print()

for i in range(3):
    print(I[i])

print()

G = [[0 for i in range(5)] for j in range(5)]

for i in range(len(G)):
	for j in range(len(G[0])):
		sum = 0
		for x in range(-1, 2):
			for y in range(-1, 2):
				if (i+x>=0 and i+x<len(Padded_I) and j+y>=0 and j+y<len(Padded_I[0])): #Calc of response at every coordinate
					sum += Padded_I[i+x][j+y]*flipped[1+x][1+y]
		G[i][j]=sum

print("Output:")    #Output after convolution
print()
for i in range(len(G)):
	print(G[i])

print("Origin in Output is at (1,1)")

