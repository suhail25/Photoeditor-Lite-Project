# -*- coding: utf-8 -*-
"""DIPassig4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mmFL__aJ23sBpGdF5bzd-zaCsWlYKid2
"""

import numpy as np
from math import atan, degrees
import cv2
import numpy as np
#from skimage.io import imread,imsave
#from skimage.util import random_noise
import matplotlib.pyplot as plt
import math 
import random 
from math import floor, ceil


"""**Q2 Start from here**"""

rgbimg1 = cv2.imread('D:/IIITD/SEMESTER-IX/DIP/Assig/Assign 4/P_SUHAIL_KHAN_2017201/rgb_lenna.tif')
rgbimg1.shape

rgbimg = cv2.cvtColor(rgbimg1, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(15,7))
plt.imshow(rgbimg)
plt.title("Input RGB image")
plt.show()

def RGB_TO_HSI(img):

    with np.errstate(divide='ignore', invalid='ignore'):

        #Load image with 32 bit floats as variable type
        rgb = np.float32(img)/255

        #Separate color channels
        red = rgb[:,:,0]
        green = rgb[:,:,1]
        blue = rgb[:,:,2]

        #Calculate Intensity
        def calc_intensity(red, blue, green):
            return np.divide(blue + green + red, 3)

        #Calculate Saturation
        def calc_saturation(red, blue, green):
            minimum = np.minimum(np.minimum(red, green), blue)
            saturation = 1 - ((3 / (red + green + blue + 0.000001)) * minimum)

            return saturation

        #Calculate Hue
        def calc_hue(red, blue, green):
            hue = np.copy(red)

            for i in range(0, blue.shape[0]):
                for j in range(0, blue.shape[1]):

                    num = 0.5 * ((red[i][j] - green[i][j]) + (red[i][j] - blue[i][j]))

                    deno = math.sqrt((red[i][j] - green[i][j])**2 + ((red[i][j] - blue[i][j]) * (green[i][j] - blue[i][j])))

                    hue[i][j] = math.acos(num / (deno+0.000001))

                    if blue[i][j] <= green[i][j]:
                        hue[i][j] = hue[i][j]
                    else:
                        hue[i][j] = ((360 * math.pi) / 180.0) - hue[i][j]

            return hue

        #Merge channels into picture and return image
        hsi = cv2.merge((calc_hue(red, blue, green), calc_saturation(red, blue, green), calc_intensity(red, blue, green)))
        
        return hsi

hsi = RGB_TO_HSI(rgbimg)
plt.figure(figsize=(15,7))
plt.imshow(hsi)
plt.title("HSI image")
plt.show()

def calc_intensity2(rgb):
    red = rgb[:,:,0]
    green = rgb[:,:,1]
    blue = rgb[:,:,2]
    return (blue//3 + green//3 + red//3)

def histo(input_image):

    l=256  #intensity range 0 - 255
    m, n = input_image.shape

    count_input=[0]*256
    count_input2 = [0]*256
    pdf_input = [0]*256
    cdf_input = [0]*256

    #reading using np.where function
    for i in range(l):
        count_input[i] = np.where(input_image == i)   #stores indices
        count_input2[i] = len(list(zip(*count_input[i])))   #store count
        pdf_input[i] = count_input2[i]/(m*n)  #store probability density 

    #plotting input image
    fig=plt.figure(figsize=(25, 10))												
    fig.add_subplot(1,2,1)
    plt.imshow(input_image, cmap='gray', vmin=0, vmax=255)
    plt.colorbar(orientation="horizontal")
    plt.title("Intensity part in HSI")

    #plotting histogram of input image
    fig.add_subplot(1,2,2)
    plt.bar([i for i in range(256)], pdf_input)
    plt.xlabel('Pixel Values')
    plt.ylabel('Count')
    plt.title("Normalized histogram of Input image")
    plt.show()

    #calculating cumulative distribution
    cdf_input[0] = pdf_input[0]
    for i in range(1,l):
        cdf_input[i] = pdf_input[i] + cdf_input[i - 1]

    #Using transformation function L-1*(cdf)
    t_s_value = [0]*256
    output_image = np.copy(input_image)

    for i in range(l):
        t_s_value[i] = round( (l - 1) * cdf_input[i] )
        output_image[ count_input[i] ] = t_s_value[i]    #mapping r to s

    #count, pdf of new equalized image
    count_output=[0]*256
    count_output2 = [0]*256
    pdf_output = [0]*256

    for i in range(l):
        count_output[i] = np.where(output_image == i)
        count_output2[i] = len(list(zip(*count_output[i])))
        pdf_output[i] = count_output2[i]/(m*n)

    print()
    print()
    fig=plt.figure(figsize=(15, 7))												
    fig.add_subplot(1,2,1)
    plt.imshow(output_image, cmap='gray', vmin=0, vmax=255)
    plt.colorbar(orientation="horizontal")
    plt.title("Equalized image")

    fig.add_subplot(1,2,2)
    plt.bar([i for i in range(256)], pdf_output)
    plt.xlabel('Pixel Values')
    plt.ylabel('Count')
    plt.title("Normalized Equalized histogram of Input image")
    plt.show()

    return output_image, pdf_input, pdf_output

#load intensity matrix
input_image=calc_intensity2(rgbimg)
#input_image=cv2.imread('/content/drive/MyDrive/Images_dip/rgb_lenna.tif',0)

output_image, pdf_input, pdf_output = histo(input_image)

new_hsi  = np.copy(hsi)
new_hsi[:,:,2] = output_image/255

plt.figure(figsize=(15,7))
plt.imshow(new_hsi)
plt.title("New HSI image")
plt.show()

def hsi2rgb(new_hsi):

    R = np.zeros([512,512])
    G = np.zeros([512,512])
    B = np.zeros([512,512])

    H = new_hsi[:,:,0]
    S = new_hsi[:,:,1]
    I = new_hsi[:,:,2]

    for i in range(512):
        for j in range(512):
            if math.radians(0) <= H[i][j] < math.radians(120):

                R[i,j] = I[i,j] * (1 + ( (S[i,j] * math.cos(H[i,j])) / math.cos(math.radians(60) - H[i,j]) ))
                B[i,j] = I[i,j] * (1 - S[i,j])
                G[i,j] = 3*I[i,j] - (R[i,j] + B[i,j])

            elif math.radians(120) <= H[i][j] < math.radians(240):
                
                Htemp = H[i,j] - math.radians(120)
                R[i,j] = I[i,j] * (1 - S[i,j])
                G[i,j] = I[i,j] * (1 + ( (S[i,j] * math.cos(Htemp)) / math.cos(math.radians(60) - Htemp) ))
                B[i,j] = 3*I[i,j] - (R[i,j] + G[i,j])

            else:

                Htemp = H[i,j] - math.radians(240)
                G[i,j] = I[i,j] * (1 - S[i,j])
                B[i,j] = I[i,j] * (1 + ( (S[i,j] * math.cos(Htemp)) / math.cos(math.radians(60) - Htemp) ))
                R[i,j] = 3*I[i,j] - (B[i,j] + G[i,j])

    new_rgbimg = cv2.merge([R,G,B])

    return new_rgbimg

new_rgbimg = hsi2rgb(new_hsi)

plt.figure(figsize=(15,7))
plt.imshow(new_rgbimg)
plt.title("Output RGB image")
plt.show()

plt.figure(figsize=(15,7))
plt.subplot(1,2,1)
plt.imshow(rgbimg)
plt.title("Input RGB image")

plt.subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_input)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Histogram of Intensity Matrix in HSI image")
plt.show()

plt.figure(figsize=(15,7))
plt.subplot(1,2,1)
plt.imshow(new_rgbimg)
plt.title("Output Equalized RGB image")

plt.subplot(1,2,2)
plt.bar([i for i in range(256)], pdf_output)
plt.xlabel('Pixel Values')
plt.ylabel('Count')
plt.title("Normalized Equalized histogram of Intensity Matrix in HSI image")
plt.show()
